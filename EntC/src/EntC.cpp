#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>
#include <iostream>
#include <filesystem>
#include "def.h"
#include "core/parser.cpp"
#include "TestEnt.h"

#include <Windows.h>

#define MAX_FUNCTION_SIZE 2048

enum flags {
	FLAG_NONE,//Normal var
	FLAG_PATH = ( 1 << 0 ),
	FLAG_STRUCT_VAR = ( 1 << 1 ),
};

struct EntVar {
	char type[MAX_NAME_LENGTH];
	char name[MAX_NAME_LENGTH];
	char expecting[MAX_NAME_LENGTH];//What does the file think we will load in
	int flags;
	u64 nameHash;
};

struct EntClass {
	char name[MAX_NAME_LENGTH];
	char parent[MAX_NAME_LENGTH];
	EntVar vars[128];
	int numVars;
};

//Note: Must be ENT_VAR varType VarName;
//so static ENT_VAR Name; must be in that order

EntClass classes[1000];
int numClasses = 0;

//If a class has a parent that has not been processed, we'll wait until it's done
EntClass* todo[1000];
int numTodo = 0;

void ParseFile(const char* path) {
	FILE* file = fopen( path, "rb" );
	if( !file ) { assert( 0 ); }
	fseek( file, 0, SEEK_END );
	u32 len = ftell( file );
	fseek( file, 0, SEEK_SET );

	char* filebuffer = ( char* ) malloc( len + 1 );
	fread( filebuffer, len, 1, file );
	fclose( file );
	filebuffer[len] = '\0';

	Parser parser( filebuffer, len );
	parser.ReadToken();

	char buffer[256]{};
	while( parser.current.type != TT_EOF ) {
		Token token = parser.ReadToken();

		//Look for macro ENT_CLASS
		if( token.type != TT_STRING )
			continue;
		if( !token.StringEquals( ( char* ) "ENT_CLASS" ) && !token.StringEquals( ( char* ) "ENT_STRUCT" ) )
			continue;
		parser.ReadToken();

		//Name
		memset( buffer, 0, 256 );
		parser.ParseString( buffer, 256 );

		EntClass* newClass = &classes[numClasses++];
		strcpy( newClass->name, buffer );

		while( parser.GetCurrent().subType != '{' )
			parser.ReadToken();

		parser.ExpectedTokenTypePunctuation( '{' );
		//Get all variable types
		while( 1 ) {
			//Exit class
			if( parser.current.subType == '}' ) {
				parser.ReadToken();
				break;
			}

			if( parser.current.subType == '{' ) {
				parser.ReadToken();
				break;
			}

			if( parser.GetCurrent().type != TT_STRING ) {
				parser.ReadToken();
				continue;
			}

			if( parser.GetCurrent().StringEquals( ( char* ) "EVAR" ) || parser.GetCurrent().StringEquals( ( char* ) "EPATH" ) ) {
				bool isPath = parser.GetCurrent().StringEquals( ( char* ) "EPATH" );


				parser.ReadToken();

				EntVar* var = &newClass->vars[newClass->numVars++];
				bool a = parser.ParseString( var->type, MAX_NAME_LENGTH );

				//Exception for pointer
				if( parser.GetCurrent().subType == '*' ) {
					parser.ReadToken();
					strcat( var->type, "*" );
				}

				bool b = parser.ParseString( var->name, MAX_NAME_LENGTH );
				bool success = ( a && b );
				if( !success ) {
					printf( "[ERROR] expected type: value instead got %s %s in %s\n", var->type, var->name, path );
				}

				var->nameHash = HashStringBad( var->name );

				if( isPath )
					var->flags |= FLAG_PATH;

				// Arguments for Value
				while( 1 ) {
					if( parser.GetCurrent().subType == ';' ) {
						parser.ReadToken();
						break;
					}
					if( parser.GetCurrent().type == TT_STRING ) {
						if( parser.GetCurrent().StringEquals( ( char* ) "ENT_RENAME" ) ) {
							parser.ReadToken();
							parser.ExpectedTokenTypePunctuation( '(' );
							parser.ParseString( var->expecting, MAX_NAME_LENGTH );
							var->nameHash = HashStringBad( var->expecting );
							parser.ExpectedTokenTypePunctuation( ')' );
						}
						else
							parser.ReadToken();
					}

				}
				//parser.ExpectedTokenTypePunctuation( ';' );
			}
			else if( parser.GetCurrent().StringEquals( ( char* ) "E_STRUCT_VAR" ) || parser.GetCurrent().StringEquals( ( char* ) "E_STRUCT_PATH" ) ) {
				EntVar* var = &newClass->vars[newClass->numVars++];
				var->flags |= FLAG_STRUCT_VAR;

				if( parser.GetCurrent().StringEquals( ( char* ) "E_STRUCT_PATH" ) ) {
					var->flags |= FLAG_PATH;
				}

				parser.ReadToken();
				parser.ExpectedTokenTypePunctuation( '(' );
				parser.ParseString( var->type, MAX_NAME_LENGTH );
				parser.ExpectedTokenTypePunctuation( ',' );
				parser.ParseString( var->name, MAX_NAME_LENGTH );
				parser.ExpectedTokenTypePunctuation( ')' );

				//Remove first . from hash name
				char tmp[64]{};
				int i = 0;
				for( i = 0; var->name[i] != '\0'; i++ ) {
					if( var->name[i] == '.' ) {
						i++;
						break;
					}
				}
				memcpy( tmp, var->name + i, strlen( var->name ) - i );
				var->nameHash = HashStringBad( tmp );
				strcpy( var->expecting, tmp );
				
			}

			else if( parser.GetCurrent().StringEquals( ( char* ) "ENT_PARENT" ) ) {
				parser.ReadToken();
				parser.ExpectedTokenTypePunctuation( '(' );
				parser.ParseString( newClass->parent, MAX_NAME_LENGTH );
				parser.ExpectedTokenTypePunctuation( ')' );
			}
			else
				parser.ReadToken();
		}
	}

	free( filebuffer );
}

const char* strpramga = "#pragma once\n";
const char* strwarn = "//THIS FILE WAS GENERATED BY EntC. DO NOT TOUCH IT.\n";

bool ParseAndPrintTypePath( EntVar* var, char* buffer ) {
	if( !strcmp( var->type, "Model*" ) ) {
		strcat( buffer, "clas->" );
		strcat( buffer, var->name );
		strcat( buffer, " = DefLoadModel( value );\n " );
		return 1;
	}
	else if( !strcmp( var->type, "Projectile*" ) ) {
		strcat( buffer, "clas->" );
		strcat( buffer, var->name );
		strcat( buffer, " = DefLoadProjectile( value );\n " );
	}
	return 0;
}

bool ParseAndPrintType( EntVar* var, char* buffer ) {
	if( !strcmp( var->type, "float" ) ) {
		strcat( buffer, "clas->" );
		strcat( buffer, var->name );
		strcat( buffer, " = atof(value);\n" );
		return true;
	}
	if( !strcmp( var->type, "int" ) ) {
		strcat( buffer, "clas->" );
		strcat( buffer, var->name );
		strcat( buffer, " = atoi(value);\n" );
		return true;
	}
	if( !strcmp( var->type, "u32" ) ) {
		strcat( buffer, "clas->" );
		strcat( buffer, var->name );
		strcat( buffer, " = atol(value);\n" );
		return true;
	
	}
	if( !strcmp( var->type, "Vec3" ) ) {
		strcat( buffer, "Vec3 in = StringToVec3( value, true );\n" );
		strcat( buffer, "\t\tclas->" );
		strcat( buffer, var->name );;
		strcat( buffer, " = in;\n" );
		return true;
	}

	printf( "[ERROR] UNSUPPORTED TYPE %s\n", var->type );
	return false;
}

void GenerateFile() {
	for( int i = 0; i < numClasses; i++ ) {
		EntClass* clas = &classes[i];
#if 1
		char name[MAX_PATH_LENGTH * 2]{};
		strcpy( name, "c:/workspace/cpp/realgame/realgame/src/generated/GEN_" );
		strcat( name, clas->name );
		strcat( name, ".h" );

		FILE* file = fopen( name, "w" );
		fwrite( strpramga, 13, 1, file );
		fwrite( strwarn, 52, 1, file );
#endif

		char switchFunction[KB( 256 )]{};//fuck it we ball i guess

		strcpy( switchFunction, "bool Set" );
		strcat( switchFunction, clas->name );
		strcat( switchFunction, "Switch_GENERATED ( " );
		strcat( switchFunction, clas->name );
		strcat( switchFunction, "* clas, char* key, char* value ) { \n" );
		strcat( switchFunction, "\tu64 hash = HashStringBad( key );\n" );
		strcat( switchFunction, "\tswitch( hash ) { \n" );
		
		for( int i = 0; i < clas->numVars; i++ ) {
			EntVar* var = &clas->vars[i];
			char hashAsStr[32]{};

			sprintf_s( hashAsStr, 32, "%llu", var->nameHash );
			strcat( switchFunction, "\tcase " );
			strcat( switchFunction, hashAsStr );
			strcat( switchFunction, "://" );
			strcat( switchFunction, (var->expecting[0]) ? var->expecting : var->name );
			strcat( switchFunction, "\n\t{ \n\t\t");
			//in = atoi, atof etc.
			char* useName = ( var->expecting[0] == '\0' ) ? var->name : var->expecting;

			bool success = false;
			if( ( var->flags & FLAG_PATH ) ) {
				ParseAndPrintTypePath( var, switchFunction );
			}else
				ParseAndPrintType( var, switchFunction );

			if( success )
				strcat( switchFunction, "\t\treturn true;\n" );

			strcat( switchFunction, "\t}return true;\n" );
		}
		strcat( switchFunction, "\t}\n" );

		//If no parent then we didn't have the variable
		if( !clas->parent[0] ) {
			strcat( switchFunction, "\treturn false;\n" );
		}
		//If parent 
		else {
			strcat( switchFunction, "\treturn Set" );
			strcat( switchFunction, clas->parent );
			strcat( switchFunction, "Switch_GENERATED ( clas " );
			strcat( switchFunction, ", key, value );\n" );
		}

		strcat( switchFunction, "}\n" );

		fwrite( switchFunction, strlen( switchFunction ), 1, file );
		fclose( file );

		std::cout << "Compiled: " << name << std::endl;
	}

}

#include <core/timer.cpp>
int main() {
	Timer t;
	//const char* baseDir = 
	const char* start = "c:\\workspace\\cpp\\realgame\\realgame\\src";
	std::string queue[100];

	int numQueue = 0;
	queue[numQueue++] = start;

	int directoriesParsed = 0;
	int filesParsed = 0;

	std::string fileList = "";
	
	while( numQueue > 0 ) {
		WIN32_FIND_DATAA find;
		std::string directory = queue[--numQueue];
		std::string searchPath = directory + "\\*";

		HANDLE file = FindFirstFileA( searchPath.c_str(), &find);

		if( file == INVALID_HANDLE_VALUE ) {
			continue;
		}

		do {
			std::string fileName = directory + "/" + find.cFileName;
			//If its a new path push it back
			if( find.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) {
				if( find.cFileName[0] == '*' || find.cFileName[0] == '.' )
					continue;
				queue[numQueue++] = fileName;
			}
			//If it ends with .h then we want to parse it
			if( fileName.substr( fileName.length() - 2, 2 ) == ".h" ) {
				if( std::string( find.cFileName ) == "def.h" ) continue;

				fileList += fileName + "\n";
				ParseFile( fileName.c_str() );
			}

		} while( FindNextFileA( file, &find ) );

		directoriesParsed++;
	}

	GenerateFile();
	t.Tick();
	std::cout << "Successfully completed in " << t.GetTimeMiliSeconds() << "ms" << std::endl;
}
