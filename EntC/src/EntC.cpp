#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>
#include "def.h"
#include "core/parser.cpp"

#include "TestEnt.h"

struct EntVar {
	char type[MAX_NAME_LENGTH];
	char name[MAX_NAME_LENGTH];
	u64 nameHash;
};

struct EntClass {
	char name[MAX_NAME_LENGTH];
	EntVar vars[128];
	int numVars;
};

//Note: Must be ENT_VAR varType VarName;
//so static ENT_VAR Name; must be in that order

EntClass classes[1000];
int numClasses = 0;


void ParseFile(const char* path) {
	FILE* file = fopen( path, "rb" );
	if( !file ) { assert( 0 ); }
	fseek( file, 0, SEEK_END );
	u32 len = ftell( file );
	fseek( file, 0, SEEK_SET );

	char* filebuffer = ( char* ) malloc( len + 1 );
	fread( filebuffer, len, 1, file );
	fclose( file );
	filebuffer[len] = '\0';

	Parser parser( filebuffer, len );
	parser.ReadToken();

	char buffer[256]{};
	while( parser.current.type != TT_EOF ) {
		Token token = parser.ReadToken();

		//Look for macro ENT_CLASS
		if( token.type != TT_STRING )
			continue;
		if( !token.StringEquals( ( char* ) "ENT_CLASS" ) && !token.StringEquals( ( char* ) "ENT_STRUCT" ) )
			continue;
		parser.ReadToken();

		//Name
		memset( buffer, 0, 256 );
		parser.ParseString( buffer, 256 );

		EntClass* newClass = &classes[numClasses++];
		strcpy( newClass->name, buffer );

		parser.ExpectedTokenTypePunctuation( '{' );
		//Get all variable types
		while( 1 ) {
			//Exit class
			if( parser.current.subType == '}' ) {
				parser.ReadToken();
				break;
			}

			if( parser.current.subType == '{' ) {
				parser.ReadToken();
				break;
			}

			if( parser.GetCurrent().type != TT_STRING ) {
				parser.ReadToken();
				continue;
			}

			if( parser.GetCurrent().StringEquals( ( char* ) "EVAR" ) ) {
				parser.ReadToken();

				EntVar* var = &newClass->vars[newClass->numVars++];
				bool a = parser.ParseString( var->type, MAX_NAME_LENGTH );
				bool b = parser.ParseString( var->name, MAX_NAME_LENGTH );
				bool success = ( a && b );
				if( !success ) {
					printf( "[ERROR] expected type: value instead got %s %s in %s\n", var->type, var->name, path );
				}

				var->nameHash = HashStringBad( var->name );
				parser.ExpectedTokenTypePunctuation( ';' );
			}
			else
				parser.ReadToken();
		}
	}

	free( filebuffer );
}

const char* strpramga = "#pragma once\n";
const char* strwarn = "//THIS FILE WAS GENERATED BY EntC. DO NOT TOUCH IT.\n";

bool ParseAndPrintType( const char* type, const char* name, char* buffer ) {
	if( !strcmp( type, "float" ) ) {
		strcat( buffer, "clas->" );
		strcat( buffer, name );
		strcat( buffer, " = atof(value);\n" );
		return true;
	}
	if( !strcmp( type, "int" ) ) {
		strcat( buffer, "clas->" );
		strcat( buffer, name );
		strcat( buffer, " = atoi(value);\n" );
		return true;
	}
	if( !strcmp( type, "u32" ) ) {
		strcat( buffer, "clas->" );
		strcat( buffer, name );
		strcat( buffer, " = atol(value);\n" );
		return true;
	
	}
	if( !strcmp( type, "Vec3" ) ) {
		strcat( buffer, "Vec3 in = StringToVec3( value, true );\n" );
		strcat( buffer, "\t\tclas->" );
		strcat( buffer, name );;
		strcat( buffer, " = in;\n" );
		return true;
	}

	printf( "[ERROR] UNSUPPORTED TYPE %s\n", type );
	return false;
}

void GenerateFile() {
	for( int i = 0; i < numClasses; i++ ) {
		EntClass* clas = classes + i;
#if 1
		char name[MAX_PATH_LENGTH]{};
		strcpy( name, "gen/GEN_" );
		strcat( name, classes->name );
		strcat( name, ".h" );

		FILE* file = fopen( name, "w" );
		fwrite( strpramga, 13, 1, file );
		fwrite( strwarn, 52, 1, file );
#endif
		for( int i = 0; i < clas->numVars; i++ ) {
			EntVar* var = &clas->vars[i];

			char setFunction[2048]{};
			char getFunction[2048]{};

			//void SetNameVar_GENERATED( className* cls, type t ){ cls->t = t; }
			strcpy( setFunction, "void Set" );
			strcat( setFunction, clas->name );
			strcat( setFunction, var->name );
			strcat( setFunction, "_GENERATED ( " );
			strcat( setFunction, clas->name );
			strcat( setFunction, "* cls, " );
			strcat( setFunction, var->type );
			strcat( setFunction, " value" );
			strcat( setFunction, " ) { " );
			strcat( setFunction, "cls->" );
			strcat( setFunction, var->name );
			strcat( setFunction, " = value; }\n" );

			//void GetNameVar_GENERATED(){ return cls->var };
			strcpy( getFunction, var->type );
			strcat( getFunction, " Get" );
			strcat( getFunction, clas->name );
			strcat( getFunction, var->name );
			strcat( getFunction, "_GENERATED (" );
			strcat( getFunction, clas->name );
			strcat( getFunction, "* cls ) { return cls->" );
			strcat( getFunction, var->name );
			strcat( getFunction, "; }\n" );
		}
		char switchFunction[KB( 256 )]{};//fuck it we ball i guess
		strcpy( switchFunction, "bool Set" );
		strcat( switchFunction, clas->name );
		strcat( switchFunction, "Switch_GENERATED ( " );
		strcat( switchFunction, clas->name );
		strcat( switchFunction, "* clas, char* key, char* value ) { \n" );
		strcat( switchFunction, "\tu64 hash = HashStringBad( key ); \n" );
		strcat( switchFunction, "\tswitch( hash ) { \n" );

		for( int i = 0; i < clas->numVars; i++ ) {
			EntVar* var = &clas->vars[i];
			char hashAsStr[32]{};
			sprintf_s( hashAsStr, 32, "%llu", var->nameHash );

			strcat( switchFunction, "\tcase " );
			strcat( switchFunction, hashAsStr );
			strcat( switchFunction, ":\n\t{\n\t\t" );

			//in = atoi, atof etc.
			bool success = ParseAndPrintType( var->type, var->name, switchFunction );
			if( success )
				strcat( switchFunction, "\t\treturn true;\n" );

			strcat( switchFunction, "\t}\n" );
		}
		strcat( switchFunction, "\t}\n" );
		strcat( switchFunction, "\treturn false;\n" );

		strcat( switchFunction, "}\n" );

		fwrite( switchFunction, strlen( switchFunction ), 1, file );
		fclose( file );
	}

}

#include <iostream>
#include <filesystem>
#include <Windows.h>
int main() {
	//const char* baseDir = 
	const char* start = "c:\\workspace\\cpp\\realgame\\realgame\\src";
	std::string queue[100];

	int numQueue = 0;
	queue[numQueue++] = start;

	int directoriesParsed = 0;
	int filesParsed = 0;

	std::string fileList = "";
	
	while( numQueue > 0 ) {
		WIN32_FIND_DATAA find;
		std::string directory = queue[--numQueue];
		std::string searchPath = directory + "\\*";

		HANDLE file = FindFirstFileA( searchPath.c_str(), &find);

		if( file == INVALID_HANDLE_VALUE ) {
			continue;
		}

		do {
			std::string fileName = directory + "/" + find.cFileName;
			//If its a new path push it back
			if( find.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) {
				if( find.cFileName[0] == '*' || find.cFileName[0] == '.' )
					continue;
				queue[numQueue++] = fileName;
			}
			//If it ends with .h then we want to parse it
			if( fileName.substr( fileName.length() - 2, 2 ) == ".h" ) {
				if( std::string( find.cFileName ) == "def.h" ) continue;

				fileList += fileName + "\n";
				ParseFile( fileName.c_str() );
			}

		} while( FindNextFileA( file, &find ) );

		directoriesParsed++;
	}

	GenerateFile();
}
