#version 440

uniform float dt;

float rand(vec2 co){
    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);
}

struct Particle	{
	vec4 pos;		//xyz = pos.	w = lifeTime [0,1]
	vec4 color;		//xyz color		w: ?
	vec4 velocity;	//xyz = vel		w = ? 
	vec4 pad;
};

//Assume Spherical
struct ParticleEmitter {
	vec3 pos; 
	float speed;

	vec3 color; 
	float range;
	
	float currentLifeTime;
	float maxLifeTime;
	float last; 
	float b;
};

layout(std430, binding = 1 ) buffer particleBuffer {
	Particle particles[];
};

layout(std430, binding = 2 ) buffer particleAddBuffer {
	uint next;
	uint pad,pad2,pad3;
	ParticleEmitter emitters[];
};


layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

void main() {
	uint id = gl_GlobalInvocationID.x;

	if ( emitters[id].currentLifeTime < emitters[id].maxLifeTime ) {
		for ( int i = 0; i < 5; i++) {
			uint particleIndex = atomicAdd(next,1) + 1;

			if ( next == 32768  ){
				atomicExchange(next,0);
			}
			particles[particleIndex].pos.xyz = emitters[id].pos.xyz;

			float a = rand( -particles[particleIndex].pos.xy + id*i );
			float b = rand( particles[particleIndex].pos.xz + id*i );
			float c = rand( particles[particleIndex].pos.zy + sin(id)*i );

			particles[particleIndex].velocity.xyz = normalize(vec3(a,b,c)) * 10.0f;
			particles[particleIndex].color.xyz = emitters[id].color.xyz;

			emitters[id].last = emitters[id].currentLifeTime;
		}
	}
	emitters[id].currentLifeTime += dt;
}