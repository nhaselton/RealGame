#version 440

float prng(in vec2 co) {
	//[0,1)
	float a = fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
	return a * 2 - 1;
}

struct Particle	{
	vec4 pos;		//xyz = pos.	w = lifeTime [0,1]
	vec4 color;		//xyz color		w: scale.x
	vec4 velocity;	//xyz = vel		w = scale.y 
	vec4 acceleration;
	vec4 UVs;
};

struct ParticleEmitter {
	vec4 pos;
	//.xyz = pos
	//.w = spawn radius
	vec4 UV;
	//.xy = (x0,y0)
	//.zw = (x1,y1)

	vec4 scale;
	//.xy = Scale(start)
	//.zw = ?? maybe Scale(End?)

	vec4 acceleration;
	//.xyz = Acceleration

	ivec4 particleCounts;
	//.x = particleOffset; //Where in the buffer does the emitter start
	//.y = numParticles;
	//.z = maxParticles;
	//.w = t2;

	vec4 spawnRate;
	//.x = spawnRate;
	//.y = particleLifeTime;
	//.z = maxEmitterLifeTime;
	//.w = currentEmitterLifetime;
};

layout(std430, binding = 3 ) buffer particleBuffer {
	Particle particles[];
};

layout(std430, binding = 4 ) buffer particleAddBuffer {
	int particlesPerEmitter[64];
	ParticleEmitter emitters[];
};

layout(std430, binding = 5 ) buffer sortedBuffer {
	int sortCount;
	uint sortIndices[];
};

layout (local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

void main() {
	//TODO Find a better way to do this. Every single particle does not need to do this
	//Maybe goes in an indirect buffer i set every frame
	sortCount = 0;

	uint id = gl_GlobalInvocationID.x;

	int emitterIndex = -1;

	//See if this is slow
	int offset = 0;
	for ( int i = 0; i < 63; i++) {
		int lessThan = offset + particlesPerEmitter[i];
		if ( id  < lessThan ){
			emitterIndex = i;
			break;
		}

		offset = lessThan;
	}

	if ( emitterIndex >= 0 ) {
		int particleIndex = emitters[emitterIndex].particleCounts.x +
		atomicAdd(emitters[emitterIndex].particleCounts.y,1);


		//Sanity check to not go over 
		if (true || 
		particleIndex < emitters[emitterIndex].particleCounts.y + emitters[emitterIndex].particleCounts.z ) {
			float a = prng( particles[particleIndex].pos.xy  );
			float b = prng( particles[particleIndex].pos.xz  );
			float c = prng( particles[particleIndex].pos.zy );

			float d = prng( vec2(particleIndex, particleIndex ));
			float e = prng( vec2(particleIndex, particles[particleIndex].pos.z ));
			float f = prng( vec2(particleIndex, gl_LocalInvocationID.x ));

			particles[particleIndex].pos.xyz = emitters[emitterIndex].pos.xyz 
				+ emitters[emitterIndex].pos.w * vec3(d,e,f);
			
			particles[particleIndex].color.w = emitters[emitterIndex].scale.x;
			particles[particleIndex].velocity.w = emitters[emitterIndex].scale.y;
			particles[particleIndex].velocity.xyz = vec3(a,b,c);
			particles[particleIndex].acceleration.xyz = emitters[emitterIndex].acceleration.xyz;
			particles[particleIndex].UVs = emitters[emitterIndex].UV;
		}else{
			atomicAdd(emitters[emitterIndex].particleCounts.y,-1);
		}
	}
}